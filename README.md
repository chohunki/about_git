# git-
Git : 코드 버전 관리 프로그램

깃의 기능: (버전관리, 동시 협업, 다른컴퓨터에 작업물 보내기

버전관리 장점: 지난 과정 확인 가능
	       이전 버전으로 돌아갈 수 있음

다른컴퓨터에 작업물 보내기: 백업본을 만든다는 것이다. 복구가 가능. 
깃허브: 외부컴퓨터 없이 내 파일을 업로드 가능

깃허브: 깃으로 관리하는 프로그램을 업로드 하는 사이트(원격 저장소 제공)
	각자 만든 내용 합치기 가능


레포지토리: 우리말로 저장소
	버전별 프로젝트 모습과 버전별 변경 사항에 대한 설명등이 담김
	.git 디렉토리(숨겨진 디렉토리) -> 이게 레포지토리

커밋: 프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 것
      커밋하는 당시에 모습을 레포지토리에 저장

레포지토리는 커밋이 저장되는곳(프로젝트 디렉토리의 각 버전이 담기는 저장소)
커밋은 프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는 행위 & 결과물

git init: 비어있는 레포지토리를 생성

커밋하기전에 해야할 것 : 깃에게 커밋한 사람 알려주기

git config user.name "cho"    -> 이름 설정
git config user.email "cho@naver.com"  -> 이메일 설정

이거 하면 커밋하면 이름이랑 이메일도 저장됨

커밋에 필요한것 : 이름 이메일  커밋에 대한 정보(커밋 메시지)
따라서 git commit -m "정보"

untracked: 깃에 의해 아직 추적되지 않고 있다. -> 버전 관리의 대상이 아니다.
커밋을 하려면 커밋할 파일을 미리 지정해줘야 함 -> 수정된 파일의 모습이 커밋에 포함될 것이라 지정하는 것(add)

git add 파일이름
	커밋에 반영될 파일로 지정됨

root-commit: 첫번째 커밋

커밋주의사항 3가지  
	1. 처음으로 커밋하기 전 사용자의 이름과 이메일 주소를 설정  
	2. 커밋메시지 남기기(옵션 -m) 
	3. 커밋할 파일을 git add로 지정해주기 


Git은 내부적으로 크게 3가지 종류의 작업 영역을 두고 동작합니다.

각 작업 영역의 이름은

working directory 
staging area  
repository  
입니다. 순서대로 하나씩 설명해드릴게요.

첫 번째 작업 영역인 working directory는 작업을 하는 프로젝트 디렉토리를 말합니다. 그러니까 지금 상황에서는 MathTool 디렉토리가 working directory입니다. 

두 번째 작업 영역인 staging area는 git add를 한 파일들이 존재하는 영역입니다. 커밋을 하게되면 staging area에 있는 파일들만 커밋에 반영됩니다. 

세 번째 작업 영역인 repository는 working directory의 변경 이력들이 저장되어 있는 영역입니다. 그러니까 커밋들이 저장되는 영역이라는 뜻인데요. 조금 풀어서 설명해볼게요. 

working directory에서 뭔가 작업을 하고,  
작업한 파일들을 git add 해주고, 
커밋을 하면 staging area에 있던 파일들의 모습이 마치 영화의 한 장면, 스냅샷(snapshot)처럼 이 repository에 저장되는 겁니다. 
![image](https://user-images.githubusercontent.com/80931911/115149310-74377300-a09e-11eb-82a1-f951a3a3dabb.png) 

왼쪽부터 순서대로 working directory, staging area, repository가 있습니다. 다음과 같은 작업을 한 상태를 나타내는 그림인데요. 

working directory에서 A.txt 파일과 B.txt 파일을 작성하고  
git add A.txt와 git add B.txt를 실행해서 A.txt, B.txt 둘다 staging area에 올렸습니다. 
그 다음 git commit -m "Ver_1"를 실행해서 staging area에 있는 파일들을 가져와 커밋으로 남겼습니다.  
Git에서 커밋을 할 때 어떤 식으로 일이 진행되는 건지 좀 이해되시죠?  
  
자, 작업을 좀더 해볼까요?   
![image](https://user-images.githubusercontent.com/80931911/115149330-84e7e900-a09e-11eb-846c-f73fd7546ec0.png) 

이전 그림에서 작업을 좀더 하고 나서의 모습인데요. 다음과 같은 작업을 추가적으로 했습니다. 

working directory에서 A.txt 파일 내용에 Python~이라는 단어를 추가, B.txt 파일 내용에 Morning!이라는 단어를 추가했습니다.  
그런데 이번에는 git add B.txt만 실행해서 B.txt 파일만 staging area에 올렸습니다.   
그 다음 git commit -m "Ver_2"로 두 번째 커밋을 했습니다.  
이전 그림과 다른 점은 A.txt는 staging area에 올리지 않고, B.txt만 staging area에 올렸다는 점입니다. 그랬더니 지금 repository에서 그 결과가 어떤가요? Ver_2 커밋을 보면 지금  

A.txt는 staging area에 있던 모습, 그러니까 수정하기 이전의 모습이 Ver_2 커밋에 반영되었고 
B.txt도 staging area에 있던 모습, 하지만 A.txt와는 달리 수정한 이후의 모습이 Ver_2 커밋에 반영되었습니다. 
A.txt, B.txt 둘다 working directory에서 수정했다는 사실은 같지만, staging area에 올렸는지 여부에 따라 그 최신 모습이 커밋에 반영되는지가 달라지는 겁니다. 바로 이 점이 Git을 사용할 때 잘 알고 기억해야하는 부분입니다.  

그런데 staging area가 굳이 왜 필요할까요? working directory에서 작업을 하고 git add할 필요없이 바로 커밋해버리는 구조가 더 편할 것 같은데 말이죠. 하지만 꼭 그렇지는 않습니다. 방금처럼 A.txt와 B.txt 파일을 둘다 수정했더라도 두 파일 모두 그 최신 모습을 다음 커밋에 반영하고 싶지 않을 수도 있습니다. 방금처럼 B.txt의 최신 모습만 그 다음 커밋에 반영하고 싶을 수도 있는 거죠. 이런 상황은 실제로 꽤 자주 있습니다. 만약 staging area가 없다면 원하는 것들만 선별적으로 커밋에 반영할 수 없게 됩니다. 그럼 좀더 세밀한 버전 관리를 할 수 없게 되는 거죠. 왜 staging area가 필요한지 알겠죠?

자, 이때까지 Git의 3가지 작업 영역과 그 관계에 대해서 알아봤는데요. 이 부분은 몇 번을 강조해도 지나치지 않을만큼 중요한 핵심 개념입니다. 이 개념을 완벽히 이해해야 나머지 내용을 배우는데 어려움이 없습니다. 꼭 제대로 이해하고 넘어가세요.

참고로 working directory는 working tree라고 하기도 하고, staging area는 index라고 할 때도 있습니다. 혹시 다른 곳에서 working tree, index 이런 단어를 쓰더라도 결국 다 우리가 배운 작업 영역들이니까 당황하지 마세요!



------------------------------
git add .  -> 현재 프로젝트 디렉토리 내에서 변경사항이 생긴 모든 파일들을 staging area에 추가하라  


이전 노트에서 Git의 3가지 작업 영역을 배웠습니다. 

작업 영역과 관련해서 한 가지 더 알아두면 좋은 내용이 있는데요.

그건 바로 Git으로 관리되는 파일은 일종의 '상태(status)'라는 걸 가진다는 사실입니다. 

일단 Git에서 파일들은 크게 다음 2가지 상태를 가집니다.

Untracked 상태  
Tracked 상태  
그리고 Tracked 상태는 다시 아래와 같은 3가지 상태로 나눌 수 있구요.   

Staged 상태 
Unmodified 상태 
Modified 상태 
각 상태를 순서대로 설명해드릴게요. 

1. Untracked 상태 

Untracked는 '추적되지 않고 있는'이라는 뜻입니다. 이 상태는 파일이 Git에 의해서 그 변동사항이 전혀 추적되고 있지 않는 상태를 뜻합니다. 예를 들어, 파일을 새로 생성하고 그 파일을 한 번도 git add 해주지 않았다면 이 상태입니다. 

2. Tracked 상태 

파일이 Git에 의해 그 변동사항이 추적되고 있는 상태입니다. 이 상태는 다시 그 특성에 따라 3가지 상태로 나뉩니다. 하나씩 설명할게요. 

(1) Staged 상태 

파일의 내용이 수정되고나서, staging area에 올라와있는 상태를 Staged(스테이징된, stage area에 올려진) 상태라고 합니다.  

새로 생성한 파일에 내용을 쓰고 git add를 해주거나 
한 번이라도 커밋에 포함됐었던 파일이라도 내용을 수정하고 git add를 해주면 이 상태입니다. 
(2) Unmodified 상태 

현재 파일의 내용이 최신 커밋의 모습과 비교했을 때 전혀 바뀐 게 없는 상태면 그 파일은 Unmodified(수정되지 않은, 변한 게 없는) 상태입니다. 커밋을 하고 난 직후에는 working directory 안의 모든 파일들이 이 상태가 됩니다. 

(3) Modified 상태 

최신 커밋의 모습과 비교했을 때 조금이라도 바뀐 내용이 있는 상태면 그 파일은 Modified(수정된) 상태입니다.  

이렇게 Git에서 파일은 매 순간 4가지 상태 중 하나의 상태에 있게 됩니다. 이 내용을 그림으로 정리하면 아래와 같습니다. 
![image](https://user-images.githubusercontent.com/80931911/115149345-9630f580-a09e-11eb-97fb-9d8571c62cb7.png) 

어떤 경우에, 어떻게 상태 전환이 발생하는지 주의깊게 살펴보세요. 각 경우를 설명하자면 아래 내용과 같습니다. 

Add the file : Untracked 상태의 파일을 처음으로 git add 해주면 Staged 상태가 됩니다. 
Edit the file : 최신 커밋과 비교했을 때 차이가 없는 Unmodified 상태의 파일의 내용을 수정하면 Modified 상태가 됩니다.  
Stage the file : Modified 상태의 파일을 git add 해주면 Staged 상태가 됩니다.   
Remove the file : 파일을 삭제하면 당연히 Git에서 더이상 인식하지 않겠죠?  
Commit : 커밋을 하면 staging area에 있던 파일들이 커밋에 반영되고, 이제 모든 파일들은 최신 커밋과 차이가 없게 되니까 Unmodified 상태가 됩니다.  
staging area에서 파일 제거 : git reset 파일이름 

커맨드들 정리 

git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성  
git config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)  
git config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보) 
git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기 
git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기  
git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기 
git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기 
git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)   
git commit -m "커밋 메시지" : 현재 staging area에 있는 것들 커밋으로 남기기  
git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력  
git push: 로컬 레포지토리->리모트 레포지토리 
git pull: 리포트 레포지토리 -> 로컬 레포지토리 

리모트 레포지토리 이유 : 안정성, 다른사람들과 협업 

원칙적으로 자신의 리모트 레포지토리에는 자신만 git push를 할 수 있습니다.   
만약 다른 사용자도 git push를 할 수 있게 해주려면 그 사용자를 해당 리모트 레포지토리의 collaborator로 지정하면 됩니다.   
git clone : 깃허브 프로젝트의 레포지토리를 그대로 복사 

이번 챕터에서 배운 커맨드들을 정리해볼게요.  

git push -u origin master : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.(-u origin master가 무슨 뜻인지는 'Git에서 브랜치 사용하기' 챕터에서 배울 거니까 걱정마세요!)  
git push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기   
git pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기  
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기  
이때까지 한 커밋들: 커밋 히스토리 
git log : 위에 있는게 가장 최근 커밋내역 
git commit --amend: 최신 커밋 수정  
커밋(commit)은 Git에서 가장 핵심적인 개념입니다. 커밋은 staging area의 현 상태를 그대로 하나의 버전으로 남기는 작업, 또는 그 결과물을 가리키는 말이라고 했는데요.

커밋에는 크게 다음과 같은 3가지 정보가 있습니다.

(1) 커밋을 한 사용자 아이디   

(2) 커밋한 날짜, 시간  

(3) 커밋 메시지  

특정 프로젝트 디렉토리가 어떻게 변해왔는지를 한 눈에 잘 파악하기 위해서는 커밋의 이런 정보들이 아주 중요합니다. 그런데 (1), (2)는 커밋을 할 때 Git에서 자동으로 기록해주지만, (3) 커밋 메시지는 커밋을 하는 사람이 매번 직접 작성하는 것이기 때문에 사람마다 그 분량이나 스타일이 제각각일 수 있습니다.  

개인 프로젝트의 경우에는 커밋 메시지를 어떻게 작성하든 큰 상관이 없을 수 있지만, 회사에서 여러 명이 참여하는 프로젝트의 경우에는 이 커밋 메시지가 아주 중요합니다. 그래서 커밋 메시지를 어떻게 작성해야하는지에 대한 규칙이 정해져있는 경우가 많은데요. 

그 규칙들은 회사마다 전부 다르겠죠? 그래도 커밋 메시지를 어떻게 작성하면 좋은지에 대한 일반론적인 가이드라인은 있습니다. 잠깐 살펴보자면 다음과 같습니다. 

1. 커밋 메시지 작성 가이드라인  
(1) 커밋 메시지의 제목과 상세 설명 사이에는 한 줄을 비워두세요.    

![image](https://user-images.githubusercontent.com/80931911/115149353-a3e67b00-a09e-11eb-977b-7b47daeb1b46.png) 

이전 영상에서 커밋 메시지를 남길 때 봤던 장면인데 기억나시나요? 지금 1번이 커밋 메시지의 제목(title), 2번이 커밋 메시지의 상세 내용(body)이라고 생각하시면 됩니다. 뭔가 상세한 설명이 필요한 커밋인 경우에는 커밋 메시지 한 줄보다는 이런 식으로 제목과 상세 내용으로 구분해서 적어주면 좋은데요. 이럴 때 제목과 상세 내용 사이에 한 줄을 띄워놓아야 나중에 커밋 메시지를 볼 때 좀더 편하게 볼 수 있습니다. 그리고 이렇게 비어있는 한 줄을 두는 것이 Git에서 공식적으로 권장하는 사항(예를 들어, 특정 명령어가 이 한 줄을 기준으로 제목과 상세 내용을 구분해서 사용한다고 합니다)이기도 하니까 꼭 지켜주세요.  

(2) 커밋 메시지의 제목 뒤에 온점(.)을 붙이지 마세요. 

(3) 커밋 메시지의 제목의 첫 번째 알파벳은 대문자로 작성하세요. 

(4) 커밋 메시지의 제목은 명령조로 작성하세요.(Fix it / Fixed it / Fixes it) 

(5) 커밋의 상세 내용에는 이런 걸 적으면 좋습니다.  

왜 커밋을 했는지 
어떤 문제가 있었고  
적용한 해결책이 어떤 효과를 가지는지  
(6) 다른 사람들이 자신의 코드를 바로 이해할 수 있다고 가정하지 말고 최대한 친절하게 작성하세요.   

2. 커밋할 때 알아야할 가이드라인 
(1) 하나의 커밋에는 하나의 수정사항, 하나의 이슈(issue)를 해결한 내용만 남기도록 하세요. 다양하게 수정을 하고나서 하나의 커밋으로 남기는 것은 좋지 않습니다. 하나의 커밋이 하나의 사실만을 갖고 있어야 나중에 이해하기 쉽습니다.   

이 말은 결국 최대한 작은 단위의 변화를 기준으로 커밋을 하라는 뜻입니다. 예를 들어 여러분이 A라는 파일에서 기존 함수를 3개 삭제하고, B라는 파일에서 기존 함수 2개를 삭제, C라는 파일에서 기존 함수를 1개 삭제했다고 합시다. 그 다음 프로그램을 실행해봤는데 오류가 생겼다면 과연 A, B, C 파일 중 무엇때문에 문제가 생긴건지 일일이 확인해보지 않는 이상 알 수 없겠죠? 이처럼 다양한 종류의 수정을 다 하고나서야 커밋을 하면 바로 그 다음에 프로그램에 문제가 생겼을 때 그 원인을 파악하는데 시간이 더 오래 걸립니다. 그리고 이렇게 하면 커밋 간의 독립성이 사라져서 나중에 프로젝트의 이력을 파악하는 일도 어려워지기도 하죠.  

하지만 어느 정도의 수정사항을 하나의 단위로 볼 것인지는 상황에 따라 조금씩 다를 수 있습니다. 회사의 규칙에 따라 다를 수도 있구요. 어찌 됐든 너무 많은 작업의 결과를 하나의 커밋으로 담지 않아야겠다는 생각을 하면서 커밋을 해야합니다. 

(2) 현재 프로젝트 디렉토리의 상태가 그 내부의 전체 코드를 실행했을 때 에러가 발생하지 않는 상태인 경우에만 커밋을 하도록 하세요. 나중에 동료 개발자가 특정 커밋의 코드로 실행했을 때 에러가 발생한다면 혼란을 줄 수 있습니다. 

커밋으로 보관된 특정 시점의 전체 코드는 항상 문제없이 실행되는 상태여야 합니다. 이미 과거의 커밋이 되어버렸다고 우리에게 쓸모없는 커밋이 되는 건 절대 아닙니다. 과거의 커밋이라도 

과거 버전의 프로그램을 사용해야하거나  
과거 커밋을 시작점으로 한 다른 방향의 별도 프로젝트를 시작하거나  
아예 그 커밋으로 현재 프로젝트를 리셋할 수도 있습니다. 
따라서 매 커밋의 코드들은 항상 정상 실행되는 상태의 코드여야 합니다. 그렇지 않으면 나중에 그 커밋을 위와 같은 용도로 사용하려고 할 때 문제가 생길 수 있습니다. 그리고 협업하는 상황을 생각해봐도 내가 남긴 커밋을 동료 개발자가 실행해봤는데 에러가 나고 실행이 되지 않는다면 좀 민망하겠죠? 따라서 커밋을 하기 전에 프로그램이 정상 실행되는지 점검하고 커밋하는 것이 좋습니다.  

자, 이때까지 커밋에 관한 가이드라인들을 살펴봤습니다. 사실 이런 가이드라인은 회사마다 다를 수 있고, 절대적인 규칙이 있는 것도 아닙니다. 어떤 경우든지 본인이 다니는 회사의 가이드라인을 잘 준수하는 것이 좋겠죠? 혹시 가이드라인이 없다고 할지라도 

나중에 다시 봤을 때 이해하는데 어려움이 없도록  
다른 동료 개발자와 협업하는 데 방해가 되지 않도록  
커밋을 남기고, 그 때마다 커밋 메시지를 잘 작성하는 것이 중요합니다. 

git config alias.history 'log —pretty=oneline’  
이렇게 쓰고 실행하고 나면 앞으로 git histroy라고만 써도 자동으로 git log --pretty=oneline을 실행하게 됩니다. 
git diff 이전커밋아이디 최근 커밋아이디 : 커밋 비교하기 
head: 보통 가장 최근에 한 커밋을 가리킨다. 
head가 가리키는 커밋에 따라 워킹 디렉토리가 구성된다.  
git reset: 과거 커밋으로 돌아가고 싶을 때  
git reset —hard 커밋아이디: 워킹 디렉토리 내부도 과거의 커밋처럼 변경됨   

![image](https://user-images.githubusercontent.com/80931911/115149369-b6f94b00-a09e-11eb-9d9d-2a53f9282882.png) 

git tag [태그 이름] [커밋 아이디]: 커밋에 태그 달기 
git tag: 모든 태그 조회 
git show [태그 이름]: 태그와 연결된 커밋 조회 
이번 챕터에서 배운 커맨드들을 정리해볼게요.  

git log : 커밋 히스토리를 출력 
git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.   
git show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인  
git commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦 
git config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정  
git diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교  
git reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)   
		(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)  
		(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)  
		(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)  
		그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨  

git tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임  
branch:하나의 코드 관리 흐름 
git branch: 브랜치들 조회 
git branch [브랜치이름]: 브랜치 생성  
git checkout [브랜치이름]: 브랜치 변경  
git checkout –b [브랜치이름]: 브랜치 생성하고 이동  
git branch –d [브랜치이름]: 브랜치 제거 

브랜치 머지  
git merge main: 현재 위치에 main 브랜치를 합치겠다.  
conflict 발생하면   
	1)발생한 파일 열고 merge의 결과가 되었으면 하는 모습대로 코드 수정하고 커밋\ 
	2)혹은 git merge —abort -> 머지를 취소 

--------------------------
-사실 브랜치(branch)는 커밋을 가리키는 존재(포인터)이고,  
-HEAD는 이런 브랜치를 통해 커밋을 간접적으로 가리키는 존재(포인터)  
-git checkout 커맨드로는 HEAD가 직접적으로 가리키는 것을 바꿀 수 있고 
-git checkout 뒤에는 커밋 아이디 또는 브랜치의 이름을 줘서 
-HEAD가 직접 커밋을 가리키거나, 브랜치를 가리키도록 할 수 있다는 뜻입니다. 




브랜치를 통해서 커밋을 가리키는 게 아니라 본인이 직접 커밋을 가리키고 있는 상태의 HEAD를 특별히 가리키는 말이 있습니다.  

바로 Detached HEAD입니다 

이렇게 HEAD가 특정 커밋을 직접 가리키게 하는 이유는 여러가지가 있을 수 있는데요.  

그 중에서 주된 이유 한 가지는 바로 과거의 특정 커밋에서 새로운 브랜치를 만들고 싶을 때입니다.  

머지의 종류에는 크게 
- Fast-forward 머지 
- 3-way 머지  

이번 챕터에서 배운 커맨드를 정리해봅시다. 

git branch [새 브랜치 이름] : 새로운 브랜치를 생성 
git checkout -b [새 브랜치 이름] : 새로운 브랜치를 생성하고 그 브랜치로 바로 이동 
git branch -d [기존 브랜치 이름] : 브랜치 삭제  
git checkout [기존 브랜치 이름] : 그 브랜치로 이동  
git merge [기존 브랜치 이름] : 현재 브랜치에 다른 브랜치를 머지  
git merge --abort : 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감    





